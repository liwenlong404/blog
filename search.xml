<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>安卓笔记1</title>
      <link href="2021/09/18/%E5%AE%89%E5%8D%93%E7%AC%94%E8%AE%B01/"/>
      <url>2021/09/18/%E5%AE%89%E5%8D%93%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://edu-teacher-li.oss-cn-beijing.aliyuncs.com/MyImg/Blog/%E5%AE%89%E5%8D%93/9.18/image-20210918143859207.png"></p><blockquote><p>约束性布局</p><pre><code>android.support.constraint.ConstraintLayout</code></pre></blockquote><blockquote><p>线性布局</p><p><code>LinearLayout</code></p></blockquote><ul><li>MainActivity已在AndroidManifest中注册，并设为LAUNCHER</li></ul><h2 id="一、布局"><a href="#一、布局" class="headerlink" title="一、布局"></a>一、布局</h2><h3 id="1、LinearLayout线性布局"><a href="#1、LinearLayout线性布局" class="headerlink" title="1、LinearLayout线性布局"></a>1、LinearLayout线性布局</h3><p><img src="https://edu-teacher-li.oss-cn-beijing.aliyuncs.com/MyImg/Blog/%E5%AE%89%E5%8D%93/9.18/image-20210918145756910.png"></p><ol><li><pre><code>wrap_content：内容匹配空间match_parent：匹配父空间</code></pre></li><li><p>LinearLayout的属性<strong>gravity</strong>，决定内部元素的位置</p><hr></li></ol><h3 id="2、RelativeLayout相对布局"><a href="#2、RelativeLayout相对布局" class="headerlink" title="2、RelativeLayout相对布局"></a>2、RelativeLayout相对布局</h3><p><img src="https://edu-teacher-li.oss-cn-beijing.aliyuncs.com/MyImg/Blog/%E5%AE%89%E5%8D%93/9.18/image-20210918163457366.png"></p><h2 id="二、组件"><a href="#二、组件" class="headerlink" title="二、组件"></a>二、组件</h2><h3 id="1、TestView跳转"><a href="#1、TestView跳转" class="headerlink" title="1、TestView跳转"></a>1、TestView跳转</h3><ol><li>声明btn</li><li>findViewById从布局文件中找到btn，并赋值</li><li>给声明的btn，设置一个点击监听器，参为匿名内部类new view.OnClickListener</li><li>重写onClick方法，Intnet跳转到另一个Activity</li></ol><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    mBtnTestView = findViewById(R.id.btn_testview);    mBtnTestView.setOnClickListener(new View.OnClickListener() &#123;        @Override        public void onClick(View view) &#123;            Intent intent = new Intent(MainActivity.this, TestViewActivity.class);            startActivity(intent);        &#125;    &#125;);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单点登录</title>
      <link href="2021/09/17/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>2021/09/17/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><h2 id="一-单点登录的实现思路"><a href="#一-单点登录的实现思路" class="headerlink" title="一-单点登录的实现思路"></a>一-单点登录的实现思路</h2><p>思维导图镇楼</p><p><img src="https://edu-teacher-li.oss-cn-beijing.aliyuncs.com/MyImg/Blog/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%20%281%29.png"></p><p>思路为：</p><ol><li><p>前端调用login接口，传递登录user参数。后端接口接收参数，并对数据进行校验。</p><p><strong>controller</strong>  （注：UcentreMmber为用户的实体类）</p><pre><code>//登录    @PostMapping(&quot;login&quot;)    public R loginUser(@RequestBody UcenterMember member)&#123;        //调用service方法实现登录        //返回token值，使用jwt生成       String token = memberService.login(member);        return R.ok().data(&quot;token&quot;,token);    &#125;</code></pre></li></ol><pre><code>  ```  service  ```  //登陆      @Override      public String login(UcenterMember member) &#123;          //获取登录手机号与密码          String mobile = member.getMobile();          String password = member.getPassword();          //非空判断          if (StringUtils.isEmpty(mobile) || StringUtils.isEmpty(password))&#123;              throw new EduException(20001,&quot;登录失败&quot;);          &#125;          //判断手机号是否正确          QueryWrapper&lt;UcenterMember&gt; queryWrapper = new QueryWrapper&lt;&gt;();          queryWrapper.eq(&quot;mobile&quot;, mobile);          UcenterMember mobileMember = baseMapper.selectOne(queryWrapper);          //判断查出对象是否为空          if (mobileMember == null)&#123;              //数据库无此手机号              throw new EduException(20001,&quot;登录失败&quot;);          &#125;          //判断密码          //将输入密码加MD5密，再进行比较          if (!MD5.encrypt(password).equals(mobileMember.getPassword()))&#123;              throw new EduException(20001,&quot;登录失败，密码错误&quot;);          &#125;          //判断用户是否被禁用          if (mobileMember.getIsDisabled())&#123;              throw new EduException(20001,&quot;登录失败，已被禁用&quot;);          &#125;          //登录成功          //生成token字符串          String jwtToken = JwtUtils.getJwtToken(mobileMember.getId(), mobileMember.getNickname());          return jwtToken;      &#125;  ```</code></pre><ol start="2"><li><p>校验成功根据id和昵称生成Token字符串，并返回</p></li><li><p>定义request拦截器，拦截request请求，判断cookie中是否有Token字符串，有就将token设置到request的header中。</p><p>这样做的原因为：为了携带Token。</p><pre><code>// http request 拦截器service.interceptors.request.use(  config =&gt; &#123;    //debugger    if (cookie.get(&#39;guli_token&#39;)) &#123;      //把获取到的cookie放到header里面      config.headers[&#39;token&#39;] = cookie.get(&#39;guli_token&#39;);    &#125;    return config  &#125;,  err =&gt; &#123;    return Promise.reject(err);  &#125;)</code></pre></li></ol><ol start="4"><li><p>前端接收Token字符串，并将Token放入cookie。并继续调用getLoginUserInfo接口。因为其形参为HttpServletRequest。</p><p>因为request的header中有Token，所以我们获取Token后，获取Token中的Id，并根据Id查询数据库获取用户信息，并将信息返回给前端。</p></li><li><p>前端得到user信息后，将信息存入cookie，并跳转首页。</p><p><strong>login前端js代码</strong></p><pre><code>//登陆    submitLogin()&#123;      //调用接口登陆      loginApi.submitLogin(this.user)      .then(response=&gt;&#123;        //获取token字符串,放入cookie        //参数：cookie名称，参数值，参数作用范围        cookie.set(&#39;guli_token&#39;,response.data.data.token,&#123;domain: &#39;localhost&#39;&#125;)        //调用接口，根据header中token获取用户信息        //之前创建了一个request拦截器，判断cookie中是否有token，有token就将其放入request的header中        loginApi.getLoginUserInfo()        .then(response=&gt;&#123;          this.loginInfo = response.data.data.userInfo          //获取用户信息，放入cookie          cookie.set(&#39;guli_ucenter&#39;,this.loginInfo,&#123;domain: &#39;localhost&#39;&#125;)        &#125;)        //跳转        window.location.href = &#39;/&#39;      &#125;)    &#125;,</code></pre></li></ol><ol start="6"><li><p>首页在created中从cookie获取用户信息，并绑定数据。页面做个判断，判断是否有用户id。有就显示用户头像、昵称和注销按钮。没有就显示登录和注册按钮</p></li><li><p>注销也很简单，清空cookie中的Token和用户信息，并刷新页面即可。</p><p><strong>首页的获取信息与登录的js代码</strong></p><pre><code>//从cookie获取用户信息    showInfo()&#123;      //从cookie获取     var userStr = cookie.get(&#39;guli_ucenter&#39;)      if (userStr)&#123;       this.loginInfo = JSON.parse(userStr)      &#125;      console.log(this.loginInfo)    &#125;,    //退出    logout()&#123;      //清空cookie      cookie.set(&#39;guli_token&#39;,&#39;&#39;,&#123;domain: &#39;localhost&#39;&#125;)      cookie.set(&#39;guli_ucenter&#39;,&#39;&#39;,&#123;domain: &#39;localhost&#39;&#125;)      //回到首页面      window.location.href =&#39;/&#39;    &#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus分页与多条件分页查询</title>
      <link href="2021/04/23/mp%E5%88%86%E9%A1%B5/"/>
      <url>2021/04/23/mp%E5%88%86%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="简单分页查询"><a href="#简单分页查询" class="headerlink" title="简单分页查询"></a>简单分页查询</h2><ol><li>使用的是mybatis-plus的分页插件</li><li>创建配置类，引入分页插件，分页插件代码例下   <pre><code>@Beanpublic PaginationInterceptor paginationInterceptor() &#123;   return new PaginationInterceptor();&#125;</code></pre></li><li>controller中使用</li><li>get方式访问，需在访问路径加入page变量(页数)，与limit变量(记录条数)。 </li><li>方法参数中也同样需加入这两个变量</li><li>创建page对象</li><li>调用page方法，进行分页查询。此page方法即mp的baseMapper中的selectPage方法。</li><li>page方法两个参数，一个为此前创建的page对象，一个为条件查询的参数，可置为null。</li><li>从page对象中获取total与record数据</li><li>返回数据。代码如下</li></ol><pre><code>@GetMapping(&quot;pageList/&#123;page&#125;/&#123;limit&#125;&quot;)    public R getPageTeacherList(@PathVariable Long page,                                @PathVariable Long limit)&#123;        //1.创建page对象        Page&lt;EduTeacher&gt; pageTeacher = new Page&lt;&gt;(page, limit);        //2.调用方法，分页查询        eduTeacherService.page(pageTeacher,  null);        //3.从pageTeacher中获取数据        long total = pageTeacher.getTotal();        List&lt;EduTeacher&gt; records = pageTeacher.getRecords();        //4.返回数据        return  R.ok().data(&quot;total&quot;,total).data(&quot;items&quot;,records);    &#125;</code></pre><ol start="11"><li>return的代码采用统一返回数据格式与链式编程，可看之前的博客<pre><code>return  R.ok().data(&quot;total&quot;,total).data(&quot;items&quot;,records);</code></pre></li></ol><h2 id="多条件组合查询带分页"><a href="#多条件组合查询带分页" class="headerlink" title="多条件组合查询带分页"></a>多条件组合查询带分页</h2><ol><li>因为需要多条件查询，所以可创建一个实体类，专门用于封装查询数据</li></ol><pre><code>@Datapublic class QueryTeacher &#123;    private String name;    private String level;    private String beginTime;    private String endTime;&#125;</code></pre><ol start="2"><li>controller的方法除了之前的两个参数，也要加上刚创建的实体类。实体类加上@RequestBody(required = false)注解，即参数需为json格式且一些数据可以不要</li><li>创建page对象</li><li>掉用service的方法实现条件查询，并分页</li><li>service中创建条件查询的方法，参数为page对象与封装查询数据的QueryTeacher对象</li><li>判断queryTeacher是否有数据，没有数据即为无条件查询分页，直接查询分页并return</li><li>queryTeacher不为空，则将queryTeacher的数据取出来</li><li>创建QueryWrapper对象</li><li>判断是否有条件值，有则拼接查询条件</li><li>使用baseMapper.selectPage()条件查询并分页，两个参数，一个为page对象，一个为查询条件QueryWrapper</li><li>service代码如下</li></ol><pre><code>@Servicepublic class EduTeacherServiceImpl extends ServiceImpl&lt;EduTeacherMapper, EduTeacher&gt; implements EduTeacherService &#123;    //条件查询带分页    @Override    public void pageListCondition(Page&lt;EduTeacher&gt; pageTeacher, QueryTeacher queryTeacher) &#123;        //1.判断是否有条件值，有，则拼接条件        if (queryTeacher == null) &#123;            //直接查询分页，不进行条件操作            baseMapper.selectPage(pageTeacher, null);            return;        &#125;        //如果queryTeacher不为空，则取值        String name=queryTeacher.getName();        String level=queryTeacher.getLevel();        String begin=queryTeacher.getBeginTime();        String end=queryTeacher.getEndTime();        //判断是否有条件值，有则拼接        QueryWrapper&lt;EduTeacher&gt; QueryWrapper = new QueryWrapper&lt;&gt;();        if (!StringUtils.isEmpty(name))&#123;            //拼接            QueryWrapper.like(&quot;name&quot;,name);        &#125;        if (!StringUtils.isEmpty(level))&#123;            QueryWrapper.eq(&quot;level&quot;,level);        &#125;        if (!StringUtils.isEmpty(begin))&#123;            QueryWrapper.ge(&quot;gmt_create&quot;,begin);        &#125;        if (!StringUtils.isEmpty(end))&#123;            QueryWrapper.le(&quot;gmt_create&quot;,end);        &#125;        //条件查询带分页        baseMapper.selectPage(pageTeacher,QueryWrapper);    &#125;&#125;</code></pre><ol start="12"><li>controller中从page对象中获取数据，并返回。controller代码如下</li></ol><pre><code> @PostMapping(&quot;moreConditionPageList/&#123;page&#125;/&#123;limit&#125;&quot;)    public R moreConditionPageList(@PathVariable Long page,                                   @PathVariable Long limit,                                   @RequestBody(required = false) QueryTeacher queryTeacher)&#123;        //创建page对象        Page&lt;EduTeacher&gt; pageTeacher = new Page&lt;&gt;(page, limit);        //调用service的方法实现条件查询并分页        eduTeacherService.pageListCondition(pageTeacher,queryTeacher);        //从pageTeacher中获取数据        long total = pageTeacher.getTotal();        List&lt;EduTeacher&gt; records = pageTeacher.getRecords();        return  R.ok().data(&quot;total&quot;,total).data(&quot;items&quot;,records);    &#125;</code></pre><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis-plus </tag>
            
            <tag> 分页 </tag>
            
            <tag> 多条件查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学公式测试</title>
      <link href="2021/01/03/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/"/>
      <url>2021/01/03/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-MathJax-渲染-LaTex-数学公式"><a href="#使用-MathJax-渲染-LaTex-数学公式" class="headerlink" title="使用 MathJax 渲染 LaTex 数学公式"></a>使用 MathJax 渲染 LaTex 数学公式</h2><p>   1.因需要cases环境，所以无法显示方程组</p><ul><li><p>$$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p></li><li><p>$\sum_{i=1}^n{a_i}$</p></li><li><p>$\lim_{x\to 0}lnx$</p></li><li><p>$\sqrt[x]{y}$</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 高数（一） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis笔记</title>
      <link href="2020/06/05/redis%E7%AC%94%E8%AE%B0/"/>
      <url>2020/06/05/redis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><pre><code>1. redis    1. 概念    2. 下载安装    3. 命令操作        1. 数据结构    4. 持久化操作    5. 使用Java客户端操作redis</code></pre><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><pre><code>1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库    1.1.什么是NOSQL        NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。        随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。        1.1.1.    NOSQL和关系型数据库比较            优点：                1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。                2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。                3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。                4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。            缺点：                1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。                2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。                3）不提供关系型数据库对事务的处理。        1.1.2.    非关系型数据库的优势：            1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。            2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。        1.1.3.    关系型数据库的优势：            1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。            2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。        1.1.4.    总结            关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，            让NoSQL数据库对关系型数据库的不足进行弥补。            一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据    1.2.主流的NOSQL产品        •    键值(Key-Value)存储数据库                相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB                典型应用： 内容缓存，主要用于处理大量数据的高访问负载。                 数据模型： 一系列键值对                优势： 快速查询                劣势： 存储的数据缺少结构化        •    列存储数据库                相关产品：Cassandra, HBase, Riak                典型应用：分布式的文件系统                数据模型：以列簇式存储，将同一列数据存在一起                优势：查找速度快，可扩展性强，更容易进行分布式扩展                劣势：功能相对局限        •    文档型数据库                相关产品：CouchDB、MongoDB                典型应用：Web应用（与Key-Value类似，Value是结构化的）                数据模型： 一系列键值对                优势：数据结构要求不严格                劣势： 查询性能不高，而且缺乏统一的查询语法        •    图形(Graph)数据库                相关数据库：Neo4J、InfoGrid、Infinite Graph                典型应用：社交网络                数据模型：图结构                优势：利用图结构相关算法。                劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。    1.3 什么是Redis        Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：            1) 字符串类型 string            2) 哈希类型 hash            3) 列表类型 list            4) 集合类型 set            5) 有序集合类型 sortedset        1.3.1 redis的应用场景            •    缓存（数据查询、短连接、新闻内容、商品内容等等）            •    聊天室的在线好友列表            •    任务队列。（秒杀、抢购、12306等等）            •    应用排行榜            •    网站访问统计            •    数据过期处理（可以精确到毫秒            •    分布式集群架构中的session分离2. 下载安装    1. 官网：https://redis.io    2. 中文网：http://www.redis.net.cn/    3. 解压直接可以使用：        * redis.windows.conf：配置文件        * redis-cli.exe：redis的客户端        * redis-server.exe：redis服务器端3. 命令操作    1. redis的数据结构：        * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构            * value的数据结构：                1) 字符串类型 string                2) 哈希类型 hash ： map格式                  3) 列表类型 list ： linkedlist格式。支持重复元素                4) 集合类型 set  ： 不允许重复元素                5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序    2. 字符串类型 string        1. 存储： set key value            127.0.0.1:6379&gt; set username zhangsan            OK        2. 获取： get key            127.0.0.1:6379&gt; get username            &quot;zhangsan&quot;        3. 删除： del key            127.0.0.1:6379&gt; del age            (integer) 1    3. 哈希类型 hash        1. 存储： hset key field value            127.0.0.1:6379&gt; hset myhash username lisi            (integer) 1            127.0.0.1:6379&gt; hset myhash password 123            (integer) 1        2. 获取：             * hget key field: 获取指定的field对应的值                127.0.0.1:6379&gt; hget myhash username                &quot;lisi&quot;            * hgetall key：获取所有的field和value                127.0.0.1:6379&gt; hgetall myhash                1) &quot;username&quot;                2) &quot;lisi&quot;                3) &quot;password&quot;                4) &quot;123&quot;        3. 删除： hdel key field            127.0.0.1:6379&gt; hdel myhash username            (integer) 1    4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）        1. 添加：            1. lpush key value: 将元素加入列表左表            2. rpush key value：将元素加入列表右边                127.0.0.1:6379&gt; lpush myList a                (integer) 1                127.0.0.1:6379&gt; lpush myList b                (integer) 2                127.0.0.1:6379&gt; rpush myList c                (integer) 3        2. 获取：            * lrange key start end ：范围获取                127.0.0.1:6379&gt; lrange myList 0 -1                1) &quot;b&quot;                2) &quot;a&quot;                3) &quot;c&quot;        3. 删除：            * lpop key： 删除列表最左边的元素，并将元素返回            * rpop key： 删除列表最右边的元素，并将元素返回    5. 集合类型 set ： 不允许重复元素        1. 存储：sadd key value            127.0.0.1:6379&gt; sadd myset a            (integer) 1            127.0.0.1:6379&gt; sadd myset a            (integer) 0        2. 获取：smembers key:获取set集合中所有元素            127.0.0.1:6379&gt; smembers myset            1) &quot;a&quot;        3. 删除：srem key value:删除set集合中的某个元素                127.0.0.1:6379&gt; srem myset a            (integer) 1    6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。        1. 存储：zadd key score value            127.0.0.1:6379&gt; zadd mysort 60 zhangsan            (integer) 1            127.0.0.1:6379&gt; zadd mysort 50 lisi            (integer) 1            127.0.0.1:6379&gt; zadd mysort 80 wangwu            (integer) 1        2. 获取：zrange key start end [withscores]            127.0.0.1:6379&gt; zrange mysort 0 -1            1) &quot;lisi&quot;            2) &quot;zhangsan&quot;            3) &quot;wangwu&quot;            127.0.0.1:6379&gt; zrange mysort 0 -1 withscores            1) &quot;zhangsan&quot;            2) &quot;60&quot;            3) &quot;wangwu&quot;            4) &quot;80&quot;            5) &quot;lisi&quot;            6) &quot;500&quot;        3. 删除：zrem key value            127.0.0.1:6379&gt; zrem mysort lisi            (integer) 1    7. 通用命令        1. keys * : 查询所有的键        2. type key ： 获取键对应的value的类型        3. del key：删除指定的key value4. 持久化    1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。    2. redis持久化机制：        1. RDB：默认方式，不需要进行配置，默认就使用这种机制            * 在一定的间隔时间中，检测key的变化情况，然后持久化数据            1. 编辑redis.windwos.conf文件                #   after 900 sec (15 min) if at least 1 key changed                save 900 1                #   after 300 sec (5 min) if at least 10 keys changed                save 300 10                #   after 60 sec if at least 10000 keys changed                save 60 10000            2. 重新启动redis服务器，并指定配置文件名称                D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf            2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据            1. 编辑redis.windwos.conf文件                appendonly no（关闭aof） --&gt; appendonly yes （开启aof）                # appendfsync always ： 每一次操作都进行持久化                appendfsync everysec ： 每隔一秒进行一次持久化                # appendfsync no     ： 不进行持久化5. Java客户端 Jedis    * Jedis: 一款java操作redis数据库的工具.    * 使用步骤：        1. 下载jedis的jar包        2. 使用            //1. 获取连接            Jedis jedis = new Jedis(&quot;localhost&quot;,6379);               //2. 操作               jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);            //3. 关闭连接            jedis.close();</code></pre><p>​<br>    6. Jedis操作各种redis中的数据结构<br>            1) 字符串类型 string<br>                set<br>                get//1. 获取连接<br>                Jedis jedis = new Jedis();//如果使用空参构造，默认值 “localhost”,6379端口<br>                //2. 操作<br>                //存储<br>                jedis.set(“username”,”zhangsan”);<br>                //获取<br>                String username = jedis.get(“username”);<br>                System.out.println(username);</p><pre><code>            //可以使用setex()方法存储可以指定过期时间的 key value            jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对            //3. 关闭连接            jedis.close();        2) 哈希类型 hash ： map格式              hset            hget            hgetAll            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // 存储hash            jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);            jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);            jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);            // 获取hash            String name = jedis.hget(&quot;user&quot;, &quot;name&quot;);            System.out.println(name);            // 获取hash的所有map中的数据            Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;);            // keyset            Set&lt;String&gt; keySet = user.keySet();            for (String key : keySet) &#123;                //获取value                String value = user.get(key);                System.out.println(key + &quot;:&quot; + value);            &#125;            //3. 关闭连接            jedis.close();        3) 列表类型 list ： linkedlist格式。支持重复元素            lpush / rpush            lpop / rpop            lrange start end : 范围获取             //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // list 存储            jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存            jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存            // list 范围获取            List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist);            // list 弹出            String element1 = jedis.lpop(&quot;mylist&quot;);//c            System.out.println(element1);            String element2 = jedis.rpop(&quot;mylist&quot;);//c            System.out.println(element2);            // list 范围获取            List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1);            System.out.println(mylist2);            //3. 关闭连接            jedis.close();        4) 集合类型 set  ： 不允许重复元素            sadd            smembers:获取所有元素            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作</code></pre><p>​<br>                // set 存储<br>                jedis.sadd(“myset”,”java”,”php”,”c++”);</p><pre><code>            // set 获取            Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;);            System.out.println(myset);            //3. 关闭连接            jedis.close();        5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序            zadd            zrange            //1. 获取连接            Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口            //2. 操作            // sortedset 存储            jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;);            jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;);            jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;);            // sortedset 获取            Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1);            System.out.println(mysortedset);</code></pre><p>​<br>                //3. 关闭连接<br>                jedis.close();</p><p>​<br>        * jedis连接池： JedisPool<br>            * 使用：<br>                1. 创建JedisPool连接池对象<br>                2. 调用方法 getResource()方法获取Jedis连接<br>                    //0.创建一个配置对象</p><pre><code>                JedisPoolConfig config = new JedisPoolConfig();                config.setMaxTotal(50);                config.setMaxIdle(10);                //1.创建Jedis连接池对象                JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379);</code></pre><p>​<br>                    //2.获取连接<br>                    Jedis jedis = jedisPool.getResource();<br>                    //3. 使用<br>                    jedis.set(“hehe”,”heihei”);</p><pre><code>                //4. 关闭 归还到连接池中                jedis.close();        * 连接池工具类            public class JedisPoolUtils &#123;                private static JedisPool jedisPool;                static&#123;                    //读取配置文件                    InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);                    //创建Properties对象                    Properties pro = new Properties();                    //关联文件                    try &#123;                        pro.load(is);                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                    //获取数据，设置到JedisPoolConfig中                    JedisPoolConfig config = new JedisPoolConfig();                    config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;)));                    config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;)));                    //初始化JedisPool                    jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;)));</code></pre><p>​<br>                    }</p><pre><code>                /**                 * 获取连接方法                 */                public static Jedis getJedis()&#123;                    return jedisPool.getResource();                &#125;            &#125;</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>案例需求：    1. 提供index.html页面，页面中有一个省份 下拉列表    2. 当 页面加载完成后 发送ajax请求，加载所有省份* 注意：使用redis缓存一些不经常发生变化的数据。    * 数据库的数据一旦发生改变，则需要更新缓存。        * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入        * 在service对应的增删改方法中，将redis数据删除。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter&amp;Listener笔记</title>
      <link href="2020/06/05/Filter&amp;Listener%E7%AC%94%E8%AE%B0/"/>
      <url>2020/06/05/Filter&amp;Listener%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><pre><code>1. Filter：过滤器2. Listener：监听器</code></pre><h1 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h1><pre><code>1. 概念：    * 生活中的过滤器：净水器,空气净化器，土匪、    * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。    * 过滤器的作用：        * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...2. 快速入门：    1. 步骤：        1. 定义一个类，实现接口Filter        2. 复写方法        3. 配置拦截路径            1. web.xml            2. 注解    2. 代码：        @WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器        public class FilterDemo1 implements Filter &#123;            @Override            public void init(FilterConfig filterConfig) throws ServletException &#123;            &#125;            @Override            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;                System.out.println(&quot;filterDemo1被执行了....&quot;);            //放行            filterChain.doFilter(servletRequest,servletResponse);         &#125;            @Override            public void destroy() &#123;            &#125;        &#125;3. 过滤器细节：    1. web.xml配置            &lt;filter&gt;            &lt;filter-name&gt;demo1&lt;/filter-name&gt;            &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;        &lt;/filter&gt;        &lt;filter-mapping&gt;            &lt;filter-name&gt;demo1&lt;/filter-name&gt;            &lt;!-- 拦截路径 --&gt;            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;        &lt;/filter-mapping&gt;    2. 过滤器执行流程        1. 执行过滤器        2. 执行放行后的资源        3. 回来执行过滤器放行代码下边的代码    3. 过滤器生命周期方法        1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源        2. doFilter:每一次请求被拦截资源时，会执行。执行多次        3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源    4. 过滤器配置详解        * 拦截路径配置：            1. 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行            2. 拦截目录： /user/*    访问/user下的所有资源时，过滤器都会被执行            3. 后缀名拦截： *.jsp        访问所有后缀名为jsp资源时，过滤器都会被执行            4. 拦截所有资源：/*        访问所有资源时，过滤器都会被执行        * 拦截方式配置：资源被访问的方式            * 注解配置：                * 设置dispatcherTypes属性                    1. REQUEST：默认值。浏览器直接请求资源                    2. FORWARD：转发访问资源                    3. INCLUDE：包含访问资源                    4. ERROR：错误跳转资源                    5. ASYNC：异步访问资源            * web.xml配置                * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可    5. 过滤器链(配置多个过滤器)        * 执行顺序：如果有两个过滤器：过滤器1和过滤器2            1. 过滤器1            2. 过滤器2            3. 资源执行            4. 过滤器2            5. 过滤器1         * 过滤器先后顺序问题：            1. 注解配置：按照类名的字符串比较规则比较，值小的先执行                * 如： AFilter 和 BFilter，AFilter就先执行了。            2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行4. 案例：    1. 案例1_登录验证        * 需求：            1. 访问day17_case案例的资源。验证其是否登录            2. 如果登录了，则直接放行。            3. 如果没有登录，则跳转到登录页面，提示&quot;您尚未登录，请先登录&quot;。    2. 案例2_敏感词汇过滤        * 需求：            1. 对day17_case案例录入的数据进行敏感词汇过滤            2. 敏感词汇参考《敏感词汇.txt》            3. 如果是敏感词汇，替换为 ***         * 分析：            1. 对request对象进行增强。增强获取参数相关方法            2. 放行。传递代理对象        * 增强对象的功能：            * 设计模式：一些通用的解决固定问题的方式            1. 装饰模式            2. 代理模式                * 概念：                    1. 真实对象：被代理的对象                    2. 代理对象：                    3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的                 * 实现方式：                     1. 静态代理：有一个类文件描述代理模式                     2. 动态代理：在内存中形成代理类                        * 实现步骤：                            1. 代理对象和真实对象实现相同的接口                            2. 代理对象 = Proxy.newProxyInstance();                            3. 使用代理对象调用方法。                            4. 增强方法                        * 增强方式：                            1. 增强参数列表                            2. 增强返回值类型                            3. 增强方法体执行逻辑    </code></pre><h2 id="Listener：监听器"><a href="#Listener：监听器" class="headerlink" title="Listener：监听器"></a>Listener：监听器</h2><pre><code>* 概念：web的三大组件之一。    * 事件监听机制        * 事件    ：一件事情        * 事件源 ：事件发生的地方        * 监听器 ：一个对象        * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码* ServletContextListener:监听ServletContext对象的创建和销毁    * 方法：        * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法        * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法    * 步骤：        1. 定义一个类，实现ServletContextListener接口        2. 复写方法        3. 配置            1. web.xml            &lt;listener&gt;                &lt;listenerclass&gt;                    cn.itcast.web.listener.ContextLoaderListener                &lt;/listener-class&gt;</code></pre><pre><code>                   &lt;/listener&gt;                   * 指定初始化参数&lt;context-param&gt;                2. 注解：                    * @WebListener</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Filter和Listener </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BootStrap笔记</title>
      <link href="2020/06/05/BootStrap%E7%AC%94%E8%AE%B0/"/>
      <url>2020/06/05/BootStrap%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. Bootstrap</code></pre><h2 id="Bootstrap："><a href="#Bootstrap：" class="headerlink" title="Bootstrap："></a>Bootstrap：</h2><pre><code>1. 概念： 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。    * 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。    * 好处：        1. 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。        2. 响应式布局。            * 同一套页面可以兼容不同分辨率的设备。2. 快速入门    1. 下载Bootstrap    2. 在项目中将这三个文件夹复制    3. 创建html页面，引入必要的资源文件    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;zh-CN&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;        &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt;        &lt;!-- Bootstrap --&gt;        &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;                &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;                &lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;                &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;                &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;                &lt;/head&gt;                &lt;body&gt;                &lt;h1&gt;你好，世界！&lt;/h1&gt;                &lt;/body&gt;                &lt;/html&gt;</code></pre><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><pre><code>* 同一套页面可以兼容不同分辨率的设备。* 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子* 步骤：    1. 定义容器。相当于之前的table、        * 容器分类：            1. container：两边留白            2. container-fluid：每一种设备都是100%宽度    2. 定义行。相当于之前的tr   样式：row    3. 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目        * 设备代号：            1. xs：超小屏幕 手机 (&lt;768px)：col-xs-12            2. sm：小屏幕 平板 (≥768px)            3. md：中等屏幕 桌面显示器 (≥992px)            4. lg：大屏幕 大桌面显示器 (≥1200px)    * 注意：        1. 一行中如果格子数目超过12，则超出部分自动换行。        2. 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。        3. 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。</code></pre><h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><pre><code>1. 全局CSS样式：    * 按钮：class=&quot;btn btn-default&quot;    * 图片：        *  class=&quot;img-responsive&quot;：图片在任意尺寸都占100%        *  图片形状            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;：方形            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; ： 圆形            *  &lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; ：相框    * 表格        * table        * table-bordered        * table-hover    * 表单        * 给表单项添加：class=&quot;form-control&quot; 2. 组件：    * 导航条    * 分页条3. 插件：    * 轮播图</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;    &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt;    &lt;!-- Bootstrap --&gt;    &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;        </code></pre><pre><code>&lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;        &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;        &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;        &lt;style&gt;            .paddtop&#123;                padding-top: 10px;            &#125;            .search-btn&#123;                float: left;                border:1px solid #ffc900;                width: 90px;                height: 35px;                background-color:#ffc900 ;                text-align: center;                line-height: 35px;                margin-top: 15px;            &#125;            .search-input&#123;                float: left;                border:2px solid #ffc900;                width: 400px;                height: 35px;                padding-left: 5px;                margin-top: 15px;            &#125;            .jx&#123;                border-bottom: 2px solid #ffc900;                padding: 5px;            &#125;            .company&#123;                height: 40px;                background-color: #ffc900;                text-align: center;                line-height:40px ;                font-size: 8px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;       &lt;!-- 1.页眉部分--&gt;       &lt;header class=&quot;container-fluid&quot;&gt;           &lt;div class=&quot;row&quot;&gt;               &lt;img src=&quot;img/top_banner.jpg&quot; class=&quot;img-responsive&quot;&gt;           &lt;/div&gt;           &lt;div class=&quot;row paddtop&quot;&gt;               &lt;div class=&quot;col-md-3&quot;&gt;                   &lt;img src=&quot;img/logo.jpg&quot; class=&quot;img-responsive&quot;&gt;               &lt;/div&gt;               &lt;div class=&quot;col-md-5&quot;&gt;                   &lt;input class=&quot;search-input&quot; placeholder=&quot;请输入线路名称&quot;&gt;                   &lt;a class=&quot;search-btn&quot; href=&quot;#&quot;&gt;搜索&lt;/a&gt;               &lt;/div&gt;               &lt;div class=&quot;col-md-4&quot;&gt;                   &lt;img src=&quot;img/hotel_tel.png&quot; class=&quot;img-responsive&quot;&gt;               &lt;/div&gt;           &lt;/div&gt;           &lt;!--导航栏--&gt;</code></pre><pre><code>       &lt;div class=&quot;row&quot;&gt;           &lt;nav class=&quot;navbar navbar-default&quot;&gt;               &lt;div class=&quot;container-fluid&quot;&gt;                   &lt;!-- Brand and toggle get grouped for better mobile display --&gt;                   &lt;div class=&quot;navbar-header&quot;&gt;                       &lt;!-- 定义汉堡按钮 --&gt;                       &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt;                           &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                           &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;                       &lt;/button&gt;                       &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt;                   &lt;/div&gt;                   &lt;!-- Collect the nav links, forms, and other content for toggling --&gt;                   &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt;                       &lt;ul class=&quot;nav navbar-nav&quot;&gt;                           &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                           &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt;                       &lt;/ul&gt;                   &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt;               &lt;/div&gt;&lt;!-- /.container-fluid --&gt;           &lt;/nav&gt;       &lt;/div&gt;       &lt;!--轮播图--&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;               &lt;!-- Indicators --&gt;               &lt;ol class=&quot;carousel-indicators&quot;&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;                   &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;               &lt;/ol&gt;               &lt;!-- Wrapper for slides --&gt;               &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;                   &lt;div class=&quot;item active&quot;&gt;                       &lt;img src=&quot;img/banner_1.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;                   &lt;div class=&quot;item&quot;&gt;                       &lt;img src=&quot;img/banner_2.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;                   &lt;div class=&quot;item&quot;&gt;                       &lt;img src=&quot;img/banner_3.jpg&quot; alt=&quot;...&quot;&gt;                   &lt;/div&gt;               &lt;/div&gt;               &lt;!-- Controls --&gt;               &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;                   &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;                   &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt;               &lt;/a&gt;               &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;                   &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;                   &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt;               &lt;/a&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/header&gt;   &lt;!-- 2.主体部分--&gt;   &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row jx&quot;&gt;            &lt;img src=&quot;img/icon_5.jpg&quot;&gt;            &lt;span&gt;黑马精选&lt;/span&gt;        &lt;/div&gt;       &lt;div class=&quot;row paddtop&quot;&gt;           &lt;div class=&quot;col-md-3&quot;&gt;                &lt;div class=&quot;thumbnail&quot;&gt;                    &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                    &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                    &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-3&quot;&gt;               &lt;div class=&quot;thumbnail&quot;&gt;                   &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                   &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                   &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;               &lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;       &lt;div class=&quot;row jx&quot;&gt;           &lt;img src=&quot;img/icon_6.jpg&quot;&gt;           &lt;span&gt;国内游&lt;/span&gt;       &lt;/div&gt;       &lt;div class=&quot;row paddtop&quot;&gt;           &lt;div class=&quot;col-md-4&quot;&gt;               &lt;img src=&quot;img/guonei_1.jpg&quot;&gt;           &lt;/div&gt;           &lt;div class=&quot;col-md-8&quot;&gt;               &lt;div class=&quot;row&quot;&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                       &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;               &lt;/div&gt;               &lt;div class=&quot;row&quot;&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=&quot;col-md-4&quot;&gt;                       &lt;div class=&quot;thumbnail&quot;&gt;                           &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                           &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt;                           &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                       &lt;/div&gt;                   &lt;/div&gt;               &lt;/div&gt;           &lt;/div&gt;       &lt;/div&gt;   &lt;/div&gt;   &lt;!-- 3.页脚部分--&gt;   &lt;footer class=&quot;container-fluid&quot;&gt;       &lt;div class=&quot;row&quot;&gt;           &lt;img src=&quot;img/footer_service.png&quot; class=&quot;img-responsive&quot;&gt;       &lt;/div&gt;       &lt;div class=&quot;row company&quot;&gt;           江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882       &lt;/div&gt;   &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI框架 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
